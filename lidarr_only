#!/usr/bin/env python3
import os
import asyncio
import logging
import requests
from requests.exceptions import RequestException

# Set up logging to both file and console
log_file_path = os.path.join(os.path.dirname(__file__), 'lidarr_cleanup_log.txt')  # Log file path in the same directory as the script
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s]: %(message)s',
    handlers=[
        logging.FileHandler(log_file_path),  # File Handler to write logs to a file
        logging.StreamHandler()  # Stream Handler to output logs to the console
    ]
)

# Lidarr API endpoint updated to v1 with the specified URL
LIDARR_API_URL = "http://192.168.50.1:8687/api/v1"

# API key for Lidarr with the specified key
LIDARR_API_KEY = ""

# Timeout for API requests in seconds (changed to 5 minutes)
API_TIMEOUT = 300  # 5 minutes

# Function to make API requests with error handling
async def make_api_request(url, api_key, params=None):
    try:
        headers = {'X-Api-Key': api_key}
        response = await asyncio.get_event_loop().run_in_executor(None, lambda: requests.get(url, params=params, headers=headers))
        response.raise_for_status()
        return response.json()
    except RequestException as e:
        logging.error(f'Error making API request to {url}: {e}')
        return None
    except ValueError as e:
        logging.error(f'Error parsing JSON response from {url}: {e}')
        return None

# Function to make API delete with error handling
async def make_api_delete(url, api_key, params=None):
    try:
        headers = {'X-Api-Key': api_key}
        response = await asyncio.get_event_loop().run_in_executor(None, lambda: requests.delete(url, params=params, headers=headers))
        response.raise_for_status()
        return response.json()
    except RequestException as e:
        logging.error(f'Error making API delete request to {url}: {e}')
        return None
    except ValueError as e:
        logging.error(f'Error parsing JSON response from delete request to {url}: {e}')
        return None

# Function to remove stalled Lidarr downloads
async def remove_stalled_lidarr_downloads():
    logging.info('Checking Lidarr queue...')
    lidarr_url = f'{LIDARR_API_URL}/queue'
    lidarr_queue = await make_api_request(lidarr_url, LIDARR_API_KEY, {'page': '1', 'pageSize': await count_records(LIDARR_API_URL, LIDARR_API_KEY)})
    if lidarr_queue is not None and 'records' in lidarr_queue:
        logging.info('Processing Lidarr queue...')
        for item in lidarr_queue['records']:
            if 'title' in item and 'status' in item and 'trackedDownloadStatus' in item:
                logging.info(f'Checking the status of {item["title"]}')
                if item['status'] == 'warning' and item['errorMessage'] == 'The download is stalled with no connections':
                    logging.info(f'Removing stalled Lidarr download: {item["title"]}')
                    await make_api_delete(f'{LIDARR_API_URL}/queue/{item["id"]}', LIDARR_API_KEY, {'removeFromClient': 'true', 'blocklist': 'true'})
            else:
                logging.warning('Skipping item in Lidarr queue due to missing or invalid keys')
    else:
        logging.warning('Lidarr queue is None or missing "records" key')

# Make a request to view and count items in queue and return the number.
async def count_records(API_URL, API_Key):
    the_url = f'{API_URL}/queue'
    the_queue = await make_api_request(the_url, API_Key)
    if the_queue is not None and 'records' in the_queue:
        return the_queue['totalRecords']

# Main function
async def main():
    while True:
        logging.info('Running media-tools script')
        await remove_stalled_lidarr_downloads()
        logging.info('Finished running media-tools script. Sleeping for 5 minutes.')
        await asyncio.sleep(API_TIMEOUT)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
